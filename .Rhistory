if (i == 1){
bins_CESM_ens <- bins_CESM_all
} else {
bins_CESM_ens <- rbind(bins_CESM_ens, bins_CESM_all)
}
} # end of loop over all ensembles
# bins_CESM_ens[bins_CESM_ens < 1] <- NA # this is my threshold: set all relative frequencies smaller than 1% to NA
bins_CESM_ens <- na.omit(bins_CESM_ens) # omit NA values in data frame
assign(paste("bins_CESM_all",period,sep="_"), bins_CESM_ens)
# print elapsed time
new <- Sys.time() - old # calculate difference
print(paste("Period ", period, sep=""))
print(new) # print in nice format
} # end of loop over past (1) and future (2) period
bins_CESM_all_1[,2:5] <- bins_CESM_all_1[,2:5] / nyears # divide by number of years to get mean annual occurrence of
# consecutive circulation types
bins_CESM_all_2[,2:5] <- bins_CESM_all_2[,2:5] / nyears
####### ######### scaling here with past frequency, also for future period
# initiate new data.frames where I put in all the percentage values
bins_CESM_perc_1 <- bins_CESM_all_1; bins_CESM_perc_1[,2:5] <- NA
bins_CESM_perc_2 <- bins_CESM_all_2; bins_CESM_perc_2[,2:5] <- NA
vec <- 1:20 # I iterate over a block of 20 cell entries instead of the usual +1 iteration in loops
for (i in 1:840){ # loop through all ensembles (84) in blocks of ten cells (i in 1:840)
for (s in 1:4){ # loop through all seasons
a <- bins_CESM_all_1[vec+20*(i-1),c(1,s+1)] # subset data for past period
a[,3] <- bins_CESM_all_2[vec+20*(i-1),c(s+1)] # subset data for future period and write in same data frame
colnames(a) <- c("period", "CESM_1", "CESM_2") # change column names
sum_CESM_1 <- colSums(a, na.rm=TRUE) # take the sum of that weather pattern over past period
# here the scaling part: relative to seasonal total of past period
if (sum_CESM_1[2] == 0){  # if that circulation type does not occur we have a total sum of said
# circulation type = 0
bins_CESM_perc_1[vec+20*(i-1),s+1] <- 0
bins_CESM_perc_2[vec+20*(i-1),s+1] <- 0
} else {
# scaling relative to seasonal total which is 1.0 or 100%
# scale accordingly all data with percentage relative to past seasonal frequency
bins_CESM_perc_1[vec+20*(i-1),s+1] <- a[1:20,2] / sum_CESM_1[2] * 100
bins_CESM_perc_2[vec+20*(i-1),s+1] <- a[1:20,3] / sum_CESM_1[2] * 100
}
}
}
######## ~~~~~~~~~~~~~~~~~~~~~~~~~~ load in CMIP5 data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ########
# read in table with header
df_ens <- read.table(cmip5_data, header=FALSE, skip=0)
df_ens[is.na(df_ens)] <- 0 # set NA to zero
# join the three columns and create the date vector
df_ens$V1 <- as.Date(with(df_ens, paste(V1, V2, V3,sep="-")), "%Y-%m-%d")
df_ens$V2 <- NULL
df_ens$V3 <- NULL
features <- c(sprintf("e%02d", seq(1,84))) # label each ensemble column numerically with suffix 'e',
# e.g. 'e01', 'e02', 'e03', ...
colnames(df_ens)[2:ncol(df_ens)]= features[1:ncol(df_ens)-1] # rename column names
colnames(df_ens)[1] <- "time" # change name of column
for (period in 1:2){ # loop over past (1980--2008) and future (2061--2099) periods
old <- Sys.time() # get start time
if(period == 1){
start_year <- past[1]; end_year <- past[2] # period 1st Jan 1980 - 31st Dec 2017
} else if(period == 2){
start_year <- future[1]; end_year <- future[2] # period 1st Jan 2062 - 31st Dec 2099
}
df_ens_loop <- df_ens[which(df_ens[,1]>=paste(start_year,"-01-01", sep = "") &
df_ens[,1]<paste(end_year,"-01-01", sep = "")),]
# only select values from specific time period
# add season column
d <- as.Date(cut(as.Date(df_ens_loop$time, "%m/%d/%Y"), "month")) + 32
df_ens_loop$season <- factor(quarters(d), levels = c("Q1", "Q2", "Q3", "Q4"),
labels = c("winter", "spring", "summer", "fall"))
rm(d) # rm = remove, just like in bash
total <- ncol(df_ens)-1
for (i in 1:total){ # loop through all ensembles
for (weather_pattern in 1:10){ # loop over all ensembles
# create array which stores the count of weather type persistence
bins_CMIP5 <- data.frame(matrix(NA, nrow = 20, ncol = 5))
colnames(bins_CMIP5) <- c("period", "spring_cmip", "summer_cmip", "autumn_cmip", "winter_cmip")
bins_CMIP5[,1] <- 1:20 # persistence bin
bins_CMIP5[,2:5] <- 0 # set all cell values to zero at first, then continuously add +1 if certain condition is met
for (l in 1:4){ # loop over the four season, i.e. 1 = spring, 2 = summer, 3 = autumn, 4 = winter
if (l == 1){
s = 'spring'
} else if (l == 2){
s = 'summer'
} else if (l == 3){
s = 'fall'
} else if (l == 4){
s = 'winter'
}
df_loop <- df_ens_loop[df_ens_loop[,i+1] == weather_pattern & df_ens_loop$season == s, c(1,i+1)]
if (nrow(df_loop) == 0){ # break loop if subset of data is empty
next
}
df_loop$last_Date <- c(as.Date("1970-01-01",format="%Y-%m-%d"),
df_loop[1:nrow(df_loop)-1,]$time) # add in the date of the day before
df_loop$diff <- df_loop$time - df_loop$last_Date # calculate day difference
df_loop$type <- c(0,df_loop[1:nrow(df_loop)-1,]$type) # I don't know what this makes
df_loop$type <- ifelse(df_loop$type == df_loop$type,0,1)
# set flag if day is consecutive
df_loop$flag <- ifelse(df_loop$diff==1 & df_loop$type==0,0,1)
# count consecutive days with the consecutive_count() function from above
df_loop$consecutive <- consecutive_count(df_loop$flag)
# condence data.frames into smaller ones
# add + 1 as the shortest consecutive time period is one day
df_loop <- df_loop[,c("time", "last_Date", "consecutive")]
# remove consecutive weather patterns which only last one day
# (as they are kind of redundant)
# add +1 so that minimum persistence is one day
df_loop[,3] <- df_loop[,3] + 1
# same as in reanalysis, loop through consecutive column and assign +1 integers to bins data.frame
# counting number of consecutive multiple day weather periods in this part here
for (m in 1:nrow(df_loop)){ # loop through all data entries
if (m < nrow(df_loop)){ # if loop variable is not the last entry
# if entry is 1 and next one is also 1, then it's a 1-day consecutive period, i.e.
# .-.-.-1-1-.-.-, otherwise it would be the end of a multiple-day period and the index
# wouldn't be 1
if (df_loop[m,3] == 1 && df_loop[m+1,3] == 1){
# add +1 count to bins data.frame in that specific location
bins_CMIP5[df_loop[m,3],l+1] <- bins_CMIP5[df_loop[m,3],l+1] +1
# when we have the sequence: -1-2- where m is to the left
} else if (df_loop[m,3] > df_loop[m-1,3] && df_loop[m+1,3] == 1){
bins_CMIP5[df_loop[m,3],l+1] <- bins_CMIP5[df_loop[m,3],l+1] +1 # add +1 to counter
}
} else if (m == nrow(df_loop)){
bins_CMIP5[df_loop[m,3],l+1] <- bins_CMIP5[df_loop[m,3],l+1] +1 # add +1 to counter
}
}
}
# add column with info on weather pattern
bins_CMIP5[,6] <- weather_pattern; colnames(bins_CMIP5)[6] <- "type"
# continualy expand data frame so it includes all 10 weather pattern in the end
if (weather_pattern == 1){
bins_CMIP5_all <- bins_CMIP5
} else {
bins_CMIP5_all <- rbind(bins_CMIP5_all, bins_CMIP5)
}
} # end of loop over all weather patterns
# again, continually expand for each ensemble so that I have one very big data frame to work with
if (i == 1){
bins_CMIP5_ens <- bins_CMIP5_all
} else {
bins_CMIP5_ens <- rbind(bins_CMIP5_ens, bins_CMIP5_all)
}
} # end of loop over all ensembles
# bins_CESM_ens[bins_CESM_ens < 1] <- NA # this is my threshold: set all relative frequencies smaller than 1% to NA
bins_CMIP5_ens <- na.omit(bins_CMIP5_ens)
assign(paste("bins_CMIP5_all",period,sep="_"), bins_CMIP5_ens)
# print elapsed time
new <- Sys.time() - old # calculate difference
print(paste("Period ", period, sep=""))
print(new) # print in nice format
bins_CMIP5[,2:5] <- 0 # set all values to zero again for next iteration in loop
} # end of loop over past (1) and future (2) period
bins_CMIP5_all_1[,2:5] <- bins_CMIP5_all_1[,2:5] / nyears # divide by number of years to get mean annual occurrence of
# consecutive circulation types
bins_CMIP5_all_2[,2:5] <- bins_CMIP5_all_2[,2:5] / nyears
####### ######### scaling here with past frequency, also for future period
# initiate new data.frames where I put in all the percentage values
bins_CMIP5_perc_1 <- bins_CMIP5_all_1; bins_CMIP5_perc_1[,2:5] <- NA
bins_CMIP5_perc_2 <- bins_CMIP5_all_2; bins_CMIP5_perc_2[,2:5] <- NA
vec <- 1:20 # I iterate over a block of 20 cell entries instead of the usual +1 iteration in loops
for (i in 1:230){ # loop through all ensembles (23) in blocks of ten cells (i in 1:230)
for (s in 1:4){ # loop through all seasons
a <- bins_CMIP5_all_1[vec+20*(i-1),c(1,s+1)]
a[,3] <- bins_CMIP5_all_2[vec+20*(i-1),c(s+1)]
colnames(a) <- c("period", "CESM_1", "CESM_2") # change column names
sum_CMIP5_1 <- colSums(a, na.rm=TRUE) # take the sum of that weather pattern over past period
# here the scaling part: relative to seasonal total of past period
if (sum_CMIP5_1[2] == 0){
bins_CMIP5_perc_1[vec,s+1] <- 0
bins_CMIP5_perc_2[vec,s+1] <- 0
} else {
# scaling relative to seasonal total which is 1.0 or 100%
bins_CMIP5_perc_1[vec+20*(i-1),s+1] <- a[1:20,2] / sum_CMIP5_1[2] * 100
bins_CMIP5_perc_2[vec+20*(i-1),s+1] <- a[1:20,3] / sum_CMIP5_1[2] * 100
}
# bins_CESM_perc_1[bins_CESM_perc_1 == 0] <- NA; bins_CESM_perc_2[bins_CESM_perc_2 == 0] <- NA # set zeroes to NA
}
}
# as in the CESM section above, we remove here the NA entries
bins_CMIP5_perc_1[is.na(bins_CMIP5_perc_1)] <- 0
bins_CMIP5_perc_2[is.na(bins_CMIP5_perc_2)] <- 0
for (i in 1:6){
bins_CMIP5_perc_1[is.infinite(bins_CMIP5_perc_1[,i])] <- 0
bins_CMIP5_perc_2[is.infinite(bins_CMIP5_perc_2[,i])] <- 0
}
rm(bins_CMIP5, bins_CMIP5_ens, bins_CMIP5_all, df_loop, df_ens, df_ens_loop,
end_year, features, future, i, l, m, new, nyears, old,
past, s, start_year, weather_pattern, period) # clean up workspace
######## double check if stuff I do is correct ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ################################
a <- bins_ERA_perc_1[1:20,c(1,3)]
b <- bins_CESM_perc_1[which(bins_CESM_perc_1[,6] == 1),c(1,3)]
c <- bins_CESM_perc_2[which(bins_CESM_perc_2[,6] == 1),c(1,3)]
d <- bins_CMIP5_perc_1[which(bins_CMIP5_perc_1[,6] == 1),c(1,3)]
e <- bins_CMIP5_perc_2[which(bins_CMIP5_perc_2[,6] == 1),c(1,3)]
for (p in 1:20){ # loop over consecutive day period
a[p,3] <- mean(b[which(b[,1] == p),2], na.rm=TRUE) # CESM, past and future
a[p,4] <- mean(c[which(c[,1] == p),2], na.rm=TRUE)
a[p,5] <- mean(d[which(d[,1] == p),2], na.rm=TRUE) # the same for CMIP5, past and future
a[p,6] <- mean(e[which(e[,1] == p),2], na.rm=TRUE)
}
# replace all zeroes with NA;
a[a == 0] <- NA
colnames(a) <- c("period", "ERA", "CESM_1", "CESM_2", "CMIP5_1", "CMIP5_2")
rm(b, c, d, e) # clean up
View(a)
aa <- bins_ERA_all_1[1:20,c(1,3)]
bb <- bins_CESM_all_1[which(bins_CESM_all_1[,6] == 1),c(1,3)]
cc <- bins_CESM_all_2[which(bins_CESM_all_2[,6] == 1),c(1,3)]
dd <- bins_CMIP5_all_1[which(bins_CMIP5_all_1[,6] == 1),c(1,3)]
ee <- bins_CMIP5_all_2[which(bins_CMIP5_all_2[,6] == 1),c(1,3)]
for (p in 1:20){ # loop over consecutive day period
aa[p,3] <- mean(bb[which(bb[,1] == p),2], na.rm=TRUE) # CESM, past and future
aa[p,4] <- mean(cc[which(cc[,1] == p),2], na.rm=TRUE)
aa[p,5] <- mean(dd[which(dd[,1] == p),2], na.rm=TRUE) # the same for CMIP5, past and future
aa[p,6] <- mean(ee[which(ee[,1] == p),2], na.rm=TRUE)
}
# replace all zeroes with NA;
aa[aa == 0] <- NA
colnames(aa) <- c("period", "ERA", "CESM_1", "CESM_2", "CMIP5_1", "CMIP5_2")
rm(bb, cc, dd, ee) # clean up
View(aa)
rm(bins_CESM, bins_CESM_ens, cesm_data, cmip5_data, h, p, sum_CESM_1, sum_CMIP5_1,
sum_ERA, total, vec)
######## ~~~~~~~~~~~~~~~~~~~~~~~~~~ plotting routine histogram first ~~~~~~~~~~~~~~~~~~~~~~~~~~ ########
# here I plot as an example the westerly wind (W) circulation type
# during summer -> this Figure used for the presentation
a <- bins_ERA_perc_1[1:20,c(1,3)]
b <- bins_CESM_perc_1[which(bins_CESM_perc_1[,6] == 1),c(1,3)]
c <- bins_CESM_perc_2[which(bins_CESM_perc_2[,6] == 1),c(1,3)]
d <- bins_CMIP5_perc_1[which(bins_CMIP5_perc_1[,6] == 1),c(1,3)]
e <- bins_CMIP5_perc_2[which(bins_CMIP5_perc_2[,6] == 1),c(1,3)]
for (p in 1:20){ # loop over consecutive day period
a[p,3] <- mean(b[which(b[,1] == p),2], na.rm=TRUE) # CESM, past and future
a[p,4] <- mean(c[which(c[,1] == p),2], na.rm=TRUE)
a[p,5] <- mean(d[which(d[,1] == p),2], na.rm=TRUE) # the same for CMIP5, past and future
a[p,6] <- mean(e[which(e[,1] == p),2], na.rm=TRUE)
}
# replace all zeroes with NA;
a[a == 0] <- NA
colnames(a) <- c("period", "ERA", "CESM_1", "CESM_2", "CMIP5_1", "CMIP5_2")
rm(b, c, d, e) # clean up
# View(a)
# now we rearrange this data into a long format
a_long <- melt(a, id = "period")
library(ggplot2)
library(grid)
library(gridExtra)
library(ggpubr)
# preliminary bar plot with ggplot -> only plot summer (as this season has all period lengths and no NAs)
dev.new()
p1 <- ggplot(data = a_long, aes(x = period, y = value, group = variable, fill = variable)) +
geom_bar(stat='summary', position = 'dodge', fun.y = "mean") +
scale_fill_manual(values = c("black", Blues[4],  Blues[7], Reds[4], Reds[7]),
label = c("ERA-40/-Interim", "CESM past", "CESM future",
"CMIP5 past", "CMIP5 future")) +
scale_x_continuous(breaks = seq(0, 20, by = 2), limits = c(0.5,20.5)) +
scale_y_continuous(breaks = seq(0, 70, by = 5), limit = c(0, 45)) +
labs(x = "Number of consecutive days", y = "Frequency relative to seasonal occurrence [%]", colour = "grey") +
theme(legend.direction = "vertical") +
ggtitle("a) Westerly wind in summer")
p1 # ok great, the equation is correct: log(y) = ax + b, i.e. y = exp(a*x) * exp(b)
figure <- ggarrange(p1, ncol=1, nrow=1, legend="bottom")
print(figure)
# export as .png with specific filename
filename = paste('ERA_CESM_seasonal_frequency_histogram_west_summer_',method,'_2.png', sep="")
# export as a .pdf image
path <- 'E:/Praktikum MeteoSchweiz/figures/'
dev.copy(png, paste(path, filename, sep = "/"),
width = 7, height = 9, units = 'in', res = 600)
dev.off()
######## ~~~~~~~~~~~~~~~~~~~~~~~~~~ plotting routine persistence of histogram (rel.) ~~~~~~~~~~ ########
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# GET LM EQUATION AND R-SQUARED AS STRING                                                      #
# SOURCE: http://goo.gl/K4yh                                                                   #
# https://stackoverflow.com/questions/7549694/adding-regression-line-equation-and-r2-on-graph  #
lm_eqn <- function(array){                                                                     #
m <- lm(log(array[,2]) ~ array[,1]);                                                         #
# eq <- substitute(italic(y) == e^(a  ~ b %.% italic(x))*","~~italic(r)^2~"="~r2,              #
eq <- substitute(y == e^(beta[0] + beta[1] %.% x)*+ E[i]~~','~~italic(r)^2~"="~r2,
list(a = format(summary(m)$coef[1], digits = 2),                            #
b = format(summary(m)$coef[2], digits = 2),                            #
r2 = format(summary(m)$r.squared, digits = 3)))                        #
as.character(as.expression(eq));                                                             #
}                                                                                              #
# this is analogue to but the above function writes it into a fancy expression                 #
# model <- lm(data = bins_obs[,c(1,3)], log(summer_era) ~ period)                              #
# summary(model) # -> gives intercept and slop as well                                         #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
library(ggplot2)
library(grid)
library(gridExtra)
library(ggpubr)
library(cowplot)
for (i in 1:1){
for (s in 2:2){
a <- bins_ERA_perc_1[bins_ERA_perc_1[,6] == i,c(1,s+1)]
b <- bins_CESM_perc_1[which(bins_CESM_perc_1[,6] == i),c(1,s+1)]
c <- bins_CESM_perc_2[which(bins_CESM_perc_2[,6] == i),c(1,s+1)]
d <- bins_CMIP5_perc_1[which(bins_CMIP5_perc_1[,6] == i),c(1,s+1)]
e <- bins_CMIP5_perc_2[which(bins_CMIP5_perc_2[,6] == i),c(1,s+1)]
for (p in 1:20){ # take mean over ensembles
a[p,3] <- mean(b[which(b[,1] == p),2], na.rm=TRUE) # CESM, past and future
a[p,4] <- mean(c[which(c[,1] == p),2], na.rm=TRUE)
a[p,5] <- mean(d[which(d[,1] == p),2], na.rm=TRUE) # the same for CMIP5, past and future
a[p,6] <- mean(e[which(e[,1] == p),2], na.rm=TRUE)
}
}
}
# replace all zeroes with NA;
a[a == 0] <- NA
colnames(a) <- c("period", "ERA", "CESM_1", "CESM_2", "CMIP5_1", "CMIP5_2")
rm(b, c, d, e) # clean up
# preliminary bar plot with ggplot -> only plot summer (as this season has all period lengths and no NAs)
dev.new()
p1 <- ggplot() +
geom_smooth(data=a,aes(x=period,y=ERA,color="ERA", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CESM_1,color="CESM past", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CESM_2,color="CESM future", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CMIP5_1,color="CMIP5 past", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CMIP5_2,color="CMIP5 future", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_point(data=a,aes(x=period, y=ERA, color = "ERA-40/-Interim"),size = 4,alpha=.8,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CESM_1, color = "CESM past"),size=4,alpha=.8,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CESM_2, color = "CESM future"),size=4,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CMIP5_1, color = "CMIP5 past"),size=4,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CMIP5_2, color = "CMIP5 future"),size=4,na.rm=TRUE) +
scale_fill_manual(values = c("grey", "grey", "grey"), guide = FALSE) +
# legend labels are sorted alphabetically and with increasing number, i.e. CESM past > CESM future > ERA
# adjust colours as well: CESM past = blue, CESM future = red, ERA = black
scale_color_manual(values = c(Blues[7], Blues[4], Reds[7], Reds[4], "black", 'black',
Blues[4], Reds[4], Blues[7], Reds[7], "black")) +
# scale_color_manual(values = c('#bb00bb',antarctica[5],'black',
#                               antarctica[15], antarctica[5], '#00bb00', '#bb00bb', "black")) +
# label = c("CESM12-LE 1980-2018", "ERA40/-Interim 1980-2018", "test")) +
scale_x_continuous(breaks = seq(0, 10, by = 1), limits = c(1,8),
sec.axis = dup_axis(labels=NULL, name=NULL)) +
scale_y_log10(breaks = c(0.1, 1, 2, 5, 10, 20, 50, 75), limit = c(1, 50),
sec.axis = dup_axis(labels=NULL, name=NULL)) +
labs(x = "Period length [days]", y = "Frequency relative to past seasonal occurrence [%]", colour = "grey") +
# create annotation with linear model (lm) regression equation using the 'lm_eqn' function
# for this, select only first (2:10) and sixth (mean annual frequency) columns, e.g. bins_obs[, c(1,6)]
# write text at x,y position in plot and align left (hjust = 0)
geom_text() +
# create annotation with linear model (lm) regression equation using the 'lm_eqn' function
# for this, select only first (2:10) and sixth (mean annual frequency) columns, e.g. bins_obs[, c(1,6)]
# write text at x,y position in plot and align left (hjust = 0)
annotate("text", label = lm_eqn(a[,c(1,2)]), x = 1.75, y = 44, size = 7,
colour = "black", parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,3)]), x = 2.75, y = 32, size = 5,
colour = Blues[4], parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,4)]), x = 2.75, y = 27, size = 5,
colour = Blues[7], parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,5)]), x = 4.75, y = 15, size = 5,
colour = Reds[4], parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,6)]), x = 4.75, y = 12.5, size = 5,
colour = Reds[7], parse = TRUE, hjust = 0) +
# theme(panel.grid.minor = element_line(colour="grey", size=0.5)) +
ggtitle("a) Westerly wind in summer")
subplot_a <- ggarrange(p1, ncol=1, nrow=1, legend="bottom")
print(subplot_a)
# export as .png with specific filename
filename = paste('ERA_CESM_CMIP5_seasonal_frequency_persistence_with_slope.png', sep="")
# export as a .pdf image
path <- 'E:/Praktikum MeteoSchweiz/figures/'
dev.copy(png, paste(path, filename, sep = "/"),
width =9, height = 9, units = 'in', res = 300)
dev.off()
rm(a_long, aa, i, p, s)
######## ~~~~~~~~~~~~~~~~~~~~~~~~~~ preamble and data load in ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ########
if (method == 'Z500'){
classification <- 'wkwtg1d0'
} else if (method == 'PSL'){
classification <- 'wkwtp1d0'
}
cesm_data <- paste('E:/Praktikum MeteoSchweiz/cost_files/cost_CESM12-LE_historical_1960-2099_',method,'.dat', sep="")
# that's the data with all ensembles that work
cmip5_data <- paste('E:/Praktikum MeteoSchweiz/cost_files/cost_CMIP5_historical_rcp85_models_that_work.dat')
# adapting ggplot theme to suit my needs
theme_set(theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major.y = element_line(colour = "grey"),
panel.grid.major = element_line(size = 0.1),
panel.grid.major.x = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
legend.title = element_blank(),
plot.title = element_text(size = 20),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
legend.text=element_text(size=20),
legend.position = "bottom",
panel.background = element_blank(),
axis.text.x = element_text(size= 20), # set size of labels relative to
# default which is 11
axis.text.y = element_text(size= 20)))
# colour bar
# myblue = rgb(.19, .21, .58) # blue colour from my msc thesis
antarctica <- c('#960011', '#A50021', '#C80028',
'#D8152F', '#F72735', '#FF3D3D', '#FF7856',
'#FFAC75', '#FFD699', '#FFF1BC', '#BCF9FF',
'#99EAFF', '#75D3FF', '#56B0FF', '#3D87FF',
'#2857FF', '#181CF7', '#1E00E6', '#2400D8',
'#2D00C8')
Reds <- brewer.pal(9, "Reds")      # red colour scale with 9 entries
Blues <- brewer.pal(9, "Blues")    # blue colour scale with 9 entries
######## ~~~~~~~~~~~~~~~~~~~~~~~~~~ plotting routine persistence of histogram (rel.) ~~~~~~~~~~ ########
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
# GET LM EQUATION AND R-SQUARED AS STRING                                                      #
# SOURCE: http://goo.gl/K4yh                                                                   #
# https://stackoverflow.com/questions/7549694/adding-regression-line-equation-and-r2-on-graph  #
lm_eqn <- function(array){                                                                     #
m <- lm(log(array[,2]) ~ array[,1]);                                                         #
# eq <- substitute(italic(y) == e^(a  ~ b %.% italic(x))*","~~italic(r)^2~"="~r2,              #
eq <- substitute(y == e^(beta[0] + beta[1] %.% x)*+ E[i]~~','~~italic(r)^2~"="~r2,
list(a = format(summary(m)$coef[1], digits = 2),                            #
b = format(summary(m)$coef[2], digits = 2),                            #
r2 = format(summary(m)$r.squared, digits = 3)))                        #
as.character(as.expression(eq));                                                             #
}                                                                                              #
# this is analogue to but the above function writes it into a fancy expression                 #
# model <- lm(data = bins_obs[,c(1,3)], log(summer_era) ~ period)                              #
# summary(model) # -> gives intercept and slop as well                                         #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ #
library(ggplot2)
library(grid)
library(gridExtra)
library(ggpubr)
library(cowplot)
for (i in 1:1){
for (s in 2:2){
a <- bins_ERA_perc_1[bins_ERA_perc_1[,6] == i,c(1,s+1)]
b <- bins_CESM_perc_1[which(bins_CESM_perc_1[,6] == i),c(1,s+1)]
c <- bins_CESM_perc_2[which(bins_CESM_perc_2[,6] == i),c(1,s+1)]
d <- bins_CMIP5_perc_1[which(bins_CMIP5_perc_1[,6] == i),c(1,s+1)]
e <- bins_CMIP5_perc_2[which(bins_CMIP5_perc_2[,6] == i),c(1,s+1)]
for (p in 1:20){ # take mean over ensembles
a[p,3] <- mean(b[which(b[,1] == p),2], na.rm=TRUE) # CESM, past and future
a[p,4] <- mean(c[which(c[,1] == p),2], na.rm=TRUE)
a[p,5] <- mean(d[which(d[,1] == p),2], na.rm=TRUE) # the same for CMIP5, past and future
a[p,6] <- mean(e[which(e[,1] == p),2], na.rm=TRUE)
}
}
}
# replace all zeroes with NA;
a[a == 0] <- NA
colnames(a) <- c("period", "ERA", "CESM_1", "CESM_2", "CMIP5_1", "CMIP5_2")
rm(b, c, d, e) # clean up
# preliminary bar plot with ggplot -> only plot summer (as this season has all period lengths and no NAs)
dev.new()
p1 <- ggplot() +
geom_smooth(data=a,aes(x=period,y=ERA,color="ERA", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CESM_1,color="CESM past", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CESM_2,color="CESM future", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CMIP5_1,color="CMIP5 past", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_smooth(data=a,aes(x=period,y=CMIP5_2,color="CMIP5 future", fill = "grey"), method = "lm", na.rm = TRUE, se=FALSE) +
geom_point(data=a,aes(x=period, y=ERA, color = "ERA-40/-Interim"),size = 4,alpha=.8,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CESM_1, color = "CESM past"),size=4,alpha=.8,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CESM_2, color = "CESM future"),size=4,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CMIP5_1, color = "CMIP5 past"),size=4,na.rm=TRUE) +
geom_point(data=a,aes(x=period, y=CMIP5_2, color = "CMIP5 future"),size=4,na.rm=TRUE) +
scale_fill_manual(values = c("grey", "grey", "grey"), guide = FALSE) +
# legend labels are sorted alphabetically and with increasing number, i.e. CESM past > CESM future > ERA
# adjust colours as well: CESM past = blue, CESM future = red, ERA = black
scale_color_manual(values = c(Blues[7], Blues[4], Reds[7], Reds[4], "black", 'black',
Blues[4], Reds[4], Blues[7], Reds[7], "black")) +
# scale_color_manual(values = c('#bb00bb',antarctica[5],'black',
#                               antarctica[15], antarctica[5], '#00bb00', '#bb00bb', "black")) +
# label = c("CESM12-LE 1980-2018", "ERA40/-Interim 1980-2018", "test")) +
scale_x_continuous(breaks = seq(0, 10, by = 1), limits = c(1,8),
sec.axis = dup_axis(labels=NULL, name=NULL)) +
scale_y_log10(breaks = c(0.1, 1, 2, 5, 10, 20, 50, 75), limit = c(1, 50),
sec.axis = dup_axis(labels=NULL, name=NULL)) +
labs(x = "Period length [days]", y = "Frequency relative to past seasonal occurrence [%]", colour = "grey") +
# create annotation with linear model (lm) regression equation using the 'lm_eqn' function
# for this, select only first (2:10) and sixth (mean annual frequency) columns, e.g. bins_obs[, c(1,6)]
# write text at x,y position in plot and align left (hjust = 0)
geom_text() +
# create annotation with linear model (lm) regression equation using the 'lm_eqn' function
# for this, select only first (2:10) and sixth (mean annual frequency) columns, e.g. bins_obs[, c(1,6)]
# write text at x,y position in plot and align left (hjust = 0)
annotate("text", label = lm_eqn(a[,c(1,2)]), x = 1.75, y = 44, size = 7,
colour = "black", parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,3)]), x = 2.75, y = 32, size = 5,
colour = Blues[4], parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,4)]), x = 2.75, y = 27, size = 5,
colour = Blues[7], parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,5)]), x = 4.75, y = 15, size = 5,
colour = Reds[4], parse = TRUE, hjust = 0) +
annotate("text", label = lm_eqn(a[,c(1,6)]), x = 4.75, y = 12.5, size = 5,
colour = Reds[7], parse = TRUE, hjust = 0) +
# theme(panel.grid.minor = element_line(colour="grey", size=0.5)) +
ggtitle("a) Westerly wind in summer")
subplot_a <- ggarrange(p1, ncol=1, nrow=1, legend="bottom")
print(subplot_a)
# export as .png with specific filename
filename = paste('ERA_CESM_CMIP5_seasonal_frequency_persistence_with_slope.png', sep="")
# export as a .pdf image
path <- 'E:/Praktikum MeteoSchweiz/figures/'
dev.copy(png, paste(path, filename, sep = "/"),
width =9, height = 9, units = 'in', res = 300)
dev.off()
rm(a_long, aa, i, p, s)
########################
p2 <- p1 + ggtitle('b) Frequency increase')
p3 <- p1 + ggtitle('c) Persistence increase')
g2 <- ggarrange(p1,ggarrange(p2,p3,ncol=1,nrow=2,heights=c(1,1),legend="bottom",common.legend=TRUE),legend="bottom",common.legend=TRUE)
dev.new()
print(g2)
# export as .png with specific filename
filename = paste('test.png', sep="")
# export as a .pdf image
path <- 'E:/Praktikum MeteoSchweiz/figures/'
dev.copy(png, paste(path, filename, sep = "/"),
width =16, height = 9, units = 'in', res = 300)
dev.off()
